\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{oasics-v2021}
%This is a template for producing OASIcs articles. 
%See oasics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"
%
%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideOASIcs %uncomment to remove references to OASIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository
%
%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{wrapstuff}
\usepackage{numprint}
\usepackage{wrapfig}
\usepackage{amsfonts}
\usepackage{mathpartir}
\usepackage{tikz}
\usepackage{mystyle}
\usepackage{upquote}
\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Isabelle/Solidity: A Tool  for the Verification of Solidity Smart Contracts} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Asad {Ahmed}}{University of Exeter, Exeter EX4 4PY, UK \and \url{https://sites.google.com/view/asad-ahmed/home} }{a.ahmed6@exeter.ac.uk}{https://orcid.org/0000-0001-8276-0975}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

%\author{Joan R. Public\footnote{Optional footnote, e.g. to mark corresponding author}}{Department of Informatics, Dummy College, [optional: Address], Country}{joanrpublic@dummycollege.org}{[orcid]}{[funding]}
\author{Diego Marmsoler}{University of Exeter, Exeter EX4 4PY, UK}{d.marmsoler@exeter.ac.uk}{[https://orcid.org/0000−0003−2859−7673]}{[funding]}

\authorrunning{J. Open Access and J.\,R. Public} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Jane Open Access and Joan R. Public} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/
\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Program Verification, Smart Contracts, Isabelle, Solidity} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}

\end{abstract}

\section{Introduction}
\label{sec-intro}

\section{Overview}
\begin{figure}[!h]
\centering
%\begin{tikzpicture}[show background grid]
\begin{tikzpicture}[]
%PICTURE SCOPE or REFERENCEs
\node at (0, 0) (topleft) [circle] {};
%\node at (11.75, 0) (topright) [circle, draw=red, fill=red] {};
\node (topright) [circle, xshift = 10.5cm, right of = topleft] {};
\node (bottomleft) [circle, yshift = -7.25cm, below of = topleft] {};
\node (bottomright) [circle, xshift = 11.5cm, yshift = -7.25cm, below of = topleft] {};
%\draw (0,-3) [draw=red, fill=red]  -- (5, -4); % CHECK once of the grid is affecting the placement of the objects
%GRID

 \draw (2, -0.45 ) [rounded corners = 4pt, draw=black, fill=blue!4]  -- ++(8.15cm, 0) node[below left] {\textcolor{blue}{\scriptsize{Isabelle/Soildity}}}  --++(0, -5.5cm) --++(-8.15, 0)--cycle;
\draw (2, -0.35 ) [rounded corners = 4pt, draw=black, fill=red!4]  -- ++(8.18cm, 0)  --++(0, 1.3cm) --++(-8.15, 0)node[below right, xshift=2.8cm] {\textcolor{red}{\scriptsize Solidity (v 0.8.25)}}-- cycle;
%\draw (2.5, -0.65) [rounded corners = 4pt, draw=black, fill=blue!4]  -- ++(5cm, 0) --++(0, -2.65cm)--++(-5, 0)--cycle;
%\draw (2.65, -0.85) [rounded corners = 4pt, draw=black, fill=blue!4]  -- ++(3.1cm, 0) --++(0, -2.3cm)--++(-3.1, 0)--cycle;
%INPUTS
%\node (solidity) [thin, draw=black, fill=red!4,  rectangle, rounded corners= 2pt, xshift = 4.40cm, right of = topleft, inner sep = 4pt] {\scriptsize Solidity (v 0.8.25)};
\node (model) [thin, draw=black, fill=red!4,  minimum height= 0.6cm, rectangle, rounded corners= 2pt, xshift = 1.65cm, yshift = 0.10cm, right of = topleft, inner sep = 4pt] {\scriptsize Model};
\node (spec) [thin, draw=black, fill=red!4,  minimum height= 0.6cm, rectangle, rounded corners= 2pt, xshift = 3.40cm, yshift = 0.10cm, right of = topleft, inner sep = 4pt] {\scriptsize Specifications};
\node (ver) [thin, draw=black, fill=red!4,  minimum height= 0.6cm, rectangle, rounded corners= 2pt, xshift = 6.850cm, yshift = 0.10cm, right of = topleft, inner sep = 4pt] {\scriptsize{ Verification Condition Generator}};
\node (sm) [thin, draw=black, fill=blue!4,  rectangle, minimum width=2.3cm, rounded corners= 2pt, xshift = 2.85cm, yshift = -1.25cm, right of = topleft, inner sep = 4pt, align = center] {\scriptsize Isabelle/HOL};
\node (sm1) [thin, draw=black, fill=blue!4,  rectangle, minimum width=2.3cm,  xshift = 2.85cm, yshift = -2.10cm, right of = topleft, inner sep = 2pt, align = center] {\scriptsize{ State.thy,} \\[0.15] \scriptsize{State\_monad.thy,} \\[0.15] \scriptsize{Solidity.thy}};
%
%MODEL TO SM
%\draw  [draw=black, line width = 1.5pt, ->] (model.south)  to [out=270, in=90] (sm.north);; ;;
\draw  [draw=black, line width = 1.5pt, ->] (model.south)  --++(0, -0.35cm) |- (3.25cm, -0.65cm) -| (sm.north);; ;;
%%SM TO HOL CORE
\draw  [draw=black, line width = 1.5pt, <->] (sm.east)  -- ++(3.35cm, 0);;;; ;;
%
\node (dtl) [thin, draw=black, fill=blue!4,  rectangle, minimum width=4.9cm, rounded corners= 2pt, xshift = 7.90cm, yshift = -3.35cm, right of = topleft, inner sep = 4pt, align = center, rotate=90] { {\scriptsize \textcolor{white}{Isabelle/HOL}}\\[0.15] {\scriptsize \textcolor{white}{ Definitions/Theorems/Lemmas}}};
\node (dtl) [thin, draw=black, fill=blue!4,  rectangle, minimum width=4.9cm, rounded corners= 2pt, xshift = 8cm, yshift = -3.45cm, right of = topleft, inner sep = 4pt, align = center, rotate=90] { {\scriptsize Isabelle/HOL}\\[0.15] {\scriptsize  Definitions/Thoerems/Lemmas}};
\node (isac) [thin, draw=black, fill=blue!4,  rectangle, rounded corners= 2pt, minimum width= 5.5cm, xshift = 9.75cm,  yshift= -3.2cm, right of = topleft,  inner sep = 4pt,   align = center, rotate=90] { {\scriptsize Isabelle/HOL Core}};
\draw  [draw=black, line width = 1.5pt, <->] (9.52, -3) -- ++(0.95cm, 0) ;;
%%THEORIES-step02

\node (isasol) [thin, draw=black, fill=blue!4,  rectangle, minimum width=2.3cm, rounded corners= 2pt, xshift = 4.550cm, yshift = -3.55cm, right of = topleft, inner sep = 4pt, align = center] {\scriptsize Isabelle/ML};
\node (isasol1) [thin, draw=black, fill=blue!4,  rectangle, minimum width=2.3cm,  xshift = 4.550cm, yshift = -4.05cm, right of = topleft, inner sep = 4pt, align = center] {\scriptsize{ Contract.thy}};
%SPECIFICATION TO CONTRACT
\draw  [draw=black, line width = 1.5pt, ->] (spec.south)  --++(0, -0.35cm) |- (5.25cm, -0.65cm) -| (isasol.north);; ;;
%%Contract to Modeling
\draw  [draw=black, line width = 1.5pt, <->]  (sm1.south east) --++ (0, -0.5);;
\draw  [draw=black, line width = 1.5pt, ->] (isasol.east) -- ++(1.65cm, 0);;
%
%
%
\node (sc) [thin, draw=black, fill=red!4,  rectangle, rounded corners= 2pt, xshift= -0.75cm, yshift = -3.55cm, right of = topleft, inner sep = 4pt, align = center] {\scriptsize Smart Contract  \&\\[0.05pt] \scriptsize Property Specification };
\draw  [draw=black, line width = 1.5pt, ->] (sc.east) to [ out=360, in=180] (isasol.west);;
\node (vsc) [thin, draw=black, fill=green!10,  rectangle, rounded corners= 2pt, minimum width= 5.5cm, xshift = 10.75cm,  yshift= -3.2cm, right of = topleft,  inner sep = 4pt,   align = center, rotate=90] { {\scriptsize Verified Smart Contract}};
\draw  [draw=black, line width = 1.5pt, ->] (11.01, -3) -- ++(0.5cm, 0) ;;
\node (vcg) [thin, draw=black, fill=blue!4,  rectangle, minimum width=2.3cm, rounded corners= 2pt, xshift = 5.90cm, yshift = -5.10cm, right of = topleft, inner sep = 4pt, align = center] {\scriptsize \scriptsize Isabelle/HOL};

\node (vcg1) [thin, draw=black, fill=blue!4,  rectangle, minimum width=2.3cm, xshift = 5.90cm, yshift = -5.60cm, right of = topleft, inner sep = 4pt, align = center] {\scriptsize{ WP.thy}};


%%CONNECTIONS
%

\node (scp) [thin, draw=black, fill=red!4,  rectangle, rounded corners= 2pt, xshift = -0.80cm, yshift = -5.50cm, right of = topleft, inner sep = 4pt, align = center] {\scriptsize Automatic  Verification};
%
%scp to verification generator
\draw  [draw=black, line width = 1.5pt, <-]  (vcg1.west) --++ (-4.0cm, 0);;
%vcg to modeling
\draw  [draw=black, line width = 1.5pt, <->]  (vcg.west) --++(-1.8cm, 0) -| (sm1.south);;
%Contract to verification generator
\draw  [draw=black, line width = 1.5pt, <->]  (vcg.north west) --++ (0, 0.5);;
%

%WP to VCG
\draw  [draw=black, line width = 1.5pt, <-] (vcg.north)  --++(0, 4.63cm) ;; ;;

\end{tikzpicture}

\end{figure}
\label{sec-ov}
%
\section{Case Study}
We use  a case study, Casino, from VerifyThis long-term challenge. 
%
Casino is a betting game based on guessing the outcome of coin-tossing and is implemented using Solidity syntax (see Appendix \ref{sec:app1}).
%
Anytime, the game is characterized by three states, i.e., \texttt{IDLE}, \texttt{GAME\_AVAILABLE} and \texttt{BET\_PLACED}.
%
Initially, game is in \texttt{IDLE} state.
%
The game has been implemented using following functions in Solidity:
%
\begin{itemize}
\item Only operator can create a game by calling \texttt{creatGame} function which changes the state to \texttt{GAME\_AVAILABLE},  and also requires a secret number from the player to ensure unbiased and verifiable bet.
%
\item Once in \texttt{GAME\_AVAILABLE} state, a player can place a bet by invoking \texttt{placeBet} fucntion. 
%
This function saves the bet (\texttt{HEAD} or \texttt{TAIL}), amount of the bet and changes the state to \texttt{BET\_PLACED}.
\item Now, operator can decide the bet anytime by calling \texttt{decideBet} function by providing secret number generated when game was created.
%
It allows the function to verify the bet and also decide the outcome of the coin tossing (\texttt{HEAD} or \texttt{TAIL}).
%
If player wins then double the amount of the bet is transferred to the player else amount equal to the bet is transferred to the operator.
%
It also changes the state of the game to \texttt{IDLE} state.
\item Operator may add money to the bet, at anytime,  using \texttt{addToPot} but can only remove if game is in not in \texttt{BET\_PLACED} state by calling \texttt{decideBet}.
\end{itemize}
%
%%THIS CAN MOVE UP IN THE INTRODUCTION
The Casino smart contract is selected for two accounts: One, it has been implemented using sophisticated and advanced features of Solidity syntax including data types, global and local variables, functions, modifiers and precondition specifiers. 
%
Thus, requires to develop powerful equivalent syntax support in the proposed tool to embed the program logic. Two, from verification aspect, Casino has been employed as a case study in literature and hence allows to compare and report the result to gauge the performance of the proposed tool, comparatively.
%
%
\section{Specification}
In this section, we present a Solidity equivalent specification of smart contracts in Isabelle/Solidity. 
%
We primarily focused on specifications of state or local variables, data types, functions, modifiers, precondition specifiers and statements in Isabelle/Solidity.
%\vspace{-1cm}
\paragraph*{Storage Variables}
%
%
In Listing \ref{fig:isadt}, Casino smart contract is defined using Isabelle/Solidity command \texttt{\color{isacom}contract} followed by \emph{name} and list of storage variables.
%
The tool, also,  allows data-type annotations to specify the types of variables (Listing \ref{fig:isadt}).
\begin{code}{label={fig:isadt}}{isabelle}{Isabelle/Solidity data types for Casino}
contract Casino
  for state: "SType.TValue TSint"
  and operator: "SType.TValue TAddress"
  and player: "SType.TValue TAddress"
  and pot: "SType.TValue TSint"
  and hashedNumber: "SType.TValue TBytes"
  and bet: "SType.TValue TSint"
  and guess: "SType.TValue TSint"

constructor payable
where
  "skip"
\end{code}
%
\paragraph*{Methods}
%
%
A function, \texttt{decideBet}, in Listing \ref{fig:isamethod} showcases Isabelle/Solidity features to specify Solidity functions.
%
The keyword \texttt{\color{isargreen}emethod} defines \texttt{decideBet} which has a \texttt{\color{isargreen}payable}  modifier. 
%
A memory (local) variable, \texttt{secretNumber}, of  integer type is declared using keyword  \texttt{\color{isargreen}param}.
%
Isabelle/Solidity allows to specify the body of the function using \texttt{\color{isargreen}where} \texttt{"do \{\dots\}",} structure.
%
%
\begin{code}{label={fig:isamethod}}{isabelle}{Isabelle/Solidity method for Casino}
emethod decideBet payable
  param secretNumber: "SType.TValue TSint"
where
  "do {
    byOperator;
    inState (valtype.Sint 2);
    $\langle$assert$\rangle$ ((hashedNumber $\sim\textsubscript{s}$ []) $\langle$=$\rangle$ ($\langle$keccak256$\rangle$ (secretNumber $\sim$ [])));
    decl TSint secret;
    secret [] ::= IF ((secretNumber $\sim$ []) $\langle\%\rangle$ $\langle$sint$\rangle$ 2) $\langle$=$\rangle$( $\langle$sint$\rangle$ 0) 
    					THEN $\langle$sint$\rangle$ 0 ELSE $\langle$sint$\rangle$ 1;
    IF (secret $\sim$ []) $\langle$=$\rangle$(guess $\sim\textsubscript{s}$ []) THEN
      do {
        decl TSint bet_old;
        bet_old [] ::= bet $\sim\textsubscript{s}$ [];
        bet [] ::=$\textsubscript{s}$ $\langle$sint$\rangle$ 0;
        pot [] ::=$\textsubscript{s}$ ((pot $\sim\textsubscript{s}$ []) $\langle$-$\rangle$ (bet_old $\sim$ []));
        $\langle$transfer$\rangle$ (player $\sim\textsubscript{s}$ []) ((bet $\sim\textsubscript{s}$ []) $\langle$*$\rangle$ ($\langle$sint$\rangle$ 2))
      }
     ELSE
      do {
        pot [] ::=$\textsubscript{s}$ pot $\sim\textsubscript{s}$ [] $\langle$+$\rangle$ bet $\sim\textsubscript{s}$ [];
        bet [] ::=$\textsubscript{s}$ $\langle$sint$\rangle$ 0
      };
     state [] ::=$\textsubscript{s}$ $\langle$sint$\rangle$ 0
  }",
\end{code}
%
Lines 5-7, implement preconditions for Casino, i.e., only operator can call the function, game should be in \texttt{IDLE} state and \texttt{secretNumber} should be equal to the \texttt{hashedNumber}. 
%
For this purpose, Isabelle/Solidity employs \texttt{\color{isarblue}{assert}} which models the Solidity \texttt{\color{blue}{require}} command. 
%
That is, if preconditions are not met then \texttt{\color{isarblue}{assert}} throws an exception.
%
%
%
%
%

%
Isabelle/Solidity also supports Solidity statements such as control structures and assignment operators. 
%
For example, in Line 9, \texttt{\color{isarblue}{IF}}\dots \texttt{\color{isarblue}{THEN}}\dots \texttt{\color{isarblue}{ELSE}} reveals \texttt{HEAD} or \texttt{TAIL} by taking the  modulus (\texttt{$\langle\%\rangle$})of \texttt{secretNumber}. 
%
For assignment operators, Isabelle/Solidity employs storage (::=) and stack (::=$\textsubscript{s}$) assignment operators along with search operators ($\sim$ and $\sim\textsubscript{s}$ ) for respective stores. 
%

%
%Next, 
%%
%in Line 10 (of Listing \ref{fig:isamethod}), \texttt{transfer\_monad} transfers (special function) an amount  equal to the bet is transferred to the operator account.
%

%
%
\section{Verification}
%
%
%
Isabelle/Solidity facilitates invariance specification using \texttt{\color{isarblue}invariant} command over the contract balance and storage.
%
This command requires a user to provide the name of the invariant, followed by the invariant as predicates formulated over the contract's store and balance. The command then generates introduction and elimination rules which can be invoked for automated verification of the invariants.
%
\begin{Example}{Invariant}{invariant}
	Assume that we want to verify that when game is in  \texttt{BET\_PLACED} state, contract's internal balance satisfies:
	\begin{equation}
		pot\_balance(s, b)=b \ge s(\STR{pot}) + s(\STR{bet})  \quad\wedge\quad s(\STR{bet}) \leq s(\STR{pot})
	\end{equation}\label{eq:inv}
	and if not in \texttt{BET\_PLACED}, then 
\begin{equation}
		pot\_balance(s, b)=b \ge pot 
	\end{equation}\label{eq:inv1}
Above invariant ensures payout safety for players by explicitly placing upper bound on the contract balance w.r.t the amount of bet and pot  in  \texttt{BET\_PLACED} state and otherwise.
%

%
The corresponding specification in Isabelle/Solidity is given in Listing \ref{def:inv}:
\begin{code}{label={def:inv}}{isabelle}{Invariant in Isabelle/Solidity}
invariant pot_balance sb where
    "(fst sb STR ''state'' = sdata.Value (Sint 2)
      $\longrightarrow$ snd sb $\geq$ unat (valtype.sint (sdata.vt (fst sb STR ''pot''))) 
		+ unat (valtype.sint (sdata.vt (fst sb STR ''bet'')))
        $\wedge$ valtype.sint (sdata.vt (fst sb STR ''bet'')) $\leq$ 
		valtype.sint (sdata.vt (fst sb STR ''pot''))) $\wedge$
    (fst sb STR ''state'' $\neq$ sdata.Value (Sint 2)
    $\longrightarrow$  snd sb $\geq$ unat (valtype.sint (sdata.vt (fst sb STR ''pot''))))"
  for "casino"
\end{code}
\end{Example}
%

%
To formally verify the invariant, Isabelle/Solidity allows to specify the verification of invariants using \texttt{\color{isarblue}verificaiton} command. 
%
It accepts the name of the invariant, invariant and postconditions on the constructor and methods to generate proof obligations. 
%
For example, in Listing \ref{def:ver}, \texttt{creatGame\_post} is a postcondition that ensures that state of the game will be \texttt{creatGame} after the execution of \texttt{creatGame} fucntion.
%
In order to automate the verification task, the tool has weakest precondition calculus based verification condition generator to discharge the proof obligations.

\begin{code}{label={def:ver}}{isabelle}{Verification in Isabelle/Solidity}
verification pot_balance:
   pot_balance
  "K (K (K True))"
  "createGame" "createGame_post" and
  "placeBet" "placeBet_post" and
  "decideBet" "decideBet_post" and
  "addToPot" "K (K (K True))" and
  "removeFromPot" "K (K (K (K True)))"
  for "casino"
\end{code}
\vskip
\paragraph*{Discussions}
Verification of the Casino smart contract using Isabelle/Solidity resulted in the exploration of a major vulnerability, i.e., Reenetrancy.
%
While verifying the invariant in Example \autoref{ex:invariant},  it was not possible to verify unless changing the order of the Line 32 and 33 (see Appendix \ref{sec:app1}) which enabled the completion of the verification task. 
%
It is due to possibility of calling the function \texttt{decideBet} without setting \texttt{bet}=\texttt{0} which may lead to unintended behaviour.  
%

\section{Related Work}
%
Considering the mission-critical nature of the smart contracts in blockchain technology, formal methods techniques, e.g., Model Checking \cite{antonino2020formalising}, theorem proving \cite{bhargavan2016formal}, have been employed to formally specify and verify Solidity smart contracts. Model checking \cite{clarke1997model}is a push-button automatic formal methods technique, however, has limited expressiveness due to finite-state machine modelling and is prone to state-space explosion. On the other hand, theorem proving is highly-expressive and has also been utilized for the verification of Solidity smart contracts. 

In theorem proving literature, deep and shallow embedding are two common approaches for the verification of Solidity language. A deep embedding of operational semantic of Solidity in SolidiKeY \cite{ahrendt2020functional} allows to formally specify and verify smart contracts using KeY theorem prover. Similarly,Jakab \cite{zakrzewski2018towards} formalizes a Coq interpreter, utilizing deep embedding of operational semantic of Solidity, for the smart contract verification. However, aforementioned works rely on the axiomatic verification approach therefore may lead to miss corner cases in verifying smart contracts. In this direction, Diego et al. \cite{marmsoler2022isabelle}  developed a deep embedding framework for denotational semantic of Solidity in Isabelle/HOL which support correct-by-construction approach for the formal verification of smart contracts. On the other hand, there are two notable efforts for shallow embedding of Solidity in Isabelle theorem prover. Ribeiro et al. \cite{ribeiro2020formal} utilize mix of deep and shallow embedding to develop an intermediary low-level specification language, \texttt{SOLI}, for the specification and verification of Solidity smart contracts in Isabelle/HOL. Whereas \cite{marmsoler2024secure} provides a shallow embedding of operational semantic of Solidity in Isabelle/HOL. The framework is equipped with complex data types, such as mappings and arrays and verification of invariants as compared to SOLI.

Isabelle/Solidity tool, proposed in this paper, is based on the shallow embedding approach \cite{marmsoler2024secure}. 
This is mainly due to the scope of the proposed tool.
% 
 %
The objective of the proposed tool is to formally specify and verify the correctness of the Solidity smart contracts which is best served, in terms of effort and time, by shallow embedding as compare to deep embedding. This has been empirically shown in \cite{marmsoler2024secure}.

%Considering the mission-critical nature of the smart contracts in blockchain technology, various formal methods techniques, such as Model Checking, theorem proving and SMT solvers, have been employed to formally specify and verify Solidity smart contracts. 
%%
%Solidifier \cite{antonino2020formalising}, VeriSol\footnote{\url{https://github.com/Microsoft/verisol}} and solc-verify \cite{hajdu2020solc} translates a given smart contract into equivalent Boogie script, an intermediate verification language, which is then employed for formal verification using bounded model checking and SMT solvers.
%%
%Model checking is a push-button automatic  formal methods technique, however, has limited expressiveness due to finite-state machine modelling and is prone to state-space explosion.
%%
%
%%
%Theorem proving is highly-expressive formal methods technique and has also been employed to formally specify and verify Solidity smart contracts. 
%%
%SolidiKeY \cite{ahrendt2020functional} accomplishes the task of verification using KeY theorem prover for a given smart contract specified as a dynamic logic (DL) formula. 
%%
%An intermediary low-level specification language, \texttt{SOLI} \cite{ribeiro2020formal}, allows to formally specify and verify smart contracts in Isabelle/HOL (\textcolor{red}{I doubt if it is axiomatic approach for Solidity smart contracts, need your comments}). 
%%Jackob  has proposed an interpreter in Coq theorem prover for Solidity using big-step semantic approach. 
%%
%%These efforts allow to formally specify and verify the Solidity smart contracts deductively using native proof theories in corresponding theorem provers. 
%%
%The above-mentioned research work  is based on axiomatic approach, thus, limits  verification capabilities of Solidity smart contracts. 
%%
%To overcome this issue, correct by construction approach has also been employed to formally specify and verify smart contracts.
%%
%Particularly, deep \cite{marmsoler2022isabelle} and shallow embedding \cite{marmsoler2024secure} of Solidity in Isabelle/HOL facilitate formal specification and verification of Solidity smart contracts.
%%
%Also we follow a definitional approach meaning that we generate lower level definitions from higher level domain constructs which ensures consistency by construction.
% %Particularly, deep embedding of Solidity statements as a datatype in Isabelle/HOL \cite{marmsoler2022isabelle} facilitates deductive reasoning about the language itself which in turn allows to formally specify and verify complex properties of Solidity smart contracts. 
%%
%%
%%
%%On the other hand, Isabelle/Solidity \cite{marmsoler2024secure} leverages upon the shallow embedding of Solidity in Isabelle/HOL in order to reduce the signification effort for verifying smart contracts with deep embedding approach.
%%
%
%%
% Isabelle/Solidity tool, proposed in this paper, is based on the shallow embedding approach \cite{marmsoler2024secure}. 
%% 
% Although, deep embedding furnishes deductive reasoning about the Solidity language itself but results in a significant effort to develop full support for the purpose.  
%%
%On the other hand, shallow embedding approach  offers  
%%
%%Also we follow a definitional approach meaning that we generate lower level definitions from higher level domain constructs which ensures consistency by construction.
%%

\section{Conclusion}
%%
%% Bibliography
%%
%
In this paper, we present Isabelle/Solidity tool for the formal specification and verification of Solidity smart contracts. 
%
The tool facilitates Solidity data-types, functions, modifiers, statements, expressions and post/pre-condition specifiers in Isabelle/HOL.
%
%
The formal specification relies upon the underlying shallow embedding of Solidity expressions and statements as state-monads and storage models for different types of stores in Solidity.
%
For the verification purpose, tool supports invariant specification for the contract that in turn is supported by verification condition generator to automate the verification process.
%
Finally, we evaluated the approach by means of the Casino case study.
%
The use of the Isabelle/Solidity resulted in the exploration of re-entrancy vulnerability in the original version of Casino smart contract.
%
However, there are few  challenges in order to  fully cover the advanced features of Solidity. 
%

%
In this regard, inheritance is one of the most notable Solidity feature which can be introduced in the proposed tool for verifying interesting properties of the smart contracts.
%
Moreover, from the verification point-of-view, automation can be further improved by providing specialized rules w.r.t the context of the smart contracts.


%
%% Please use bibtex, 
%\nocite{*}
\bibliography{oasics-v2021-sample-article}

\appendix

\section{Casino: Solidity Smart Contract}\label{sec:app1}


\begin{code}{label={fig:casino}}{solidity}{Solidity source code for the Casino}
	contract Casino {
		enum Coin { HEADS, TAILS } ;
		enum State { IDLE, GAME_AVAILABLE,  BET_PLACED }
		State private state; 
		address public operator, player;
		uint public pot;
		bytes32 public hashedNumber;
		uint public bet;
		Coin guess;

		function createGame(bytes32 hashNum) 
			public byOperator, inState(IDLE) { 
			hashedNumber = hashNum; 
			state = GAME_AVAILABLE;
		}

		function placeBet(Coin _guess) public payable inState(GAME_AVAILABLE) {
			require (msg.sender != operator);
			require (msg.value <= pot);
			state = BET_PLACED; 
			player = msg.sender; 
			bet = msg.value; 
			guess = _guess; 
		}

 		function decideBet(uint secretNumber) 
		public byOperator, inState(BET_PLACED) { 
			require (hashedNumber == keccak256(secretNumber)); 
			Coin secret = (secretNumber % 2 == 0)? HEADS : TAILS;
			if (secret == guess) {
				pot = pot - bet;  
				player.transfer(bet*2);  
				bet = 0;} 
			else {
				pot = pot + bet; 
				bet = 0;
				}
			state = IDLE;}
		function addToPot() public payable byOperator { pot = pot + msg.value;}

		function removeFromPot(uint amount) public byOperator, noActiveBet { 
			operator.transfer(amount);  
			pot = pot - amount;}
		}
\end{code}


%\cref{testenv-proposition} and \autoref{testenv-proposition} ...
%
%\section{Theorem-like environments}\label{sec:theorem-environments}
%
%List of different predefined enumeration styles:
%
%\begin{theorem}\label{testenv-theorem}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{theorem}
%
%\begin{lemma}\label{testenv-lemma}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{lemma}
%
%\begin{corollary}\label{testenv-corollary}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{corollary}
%
%\begin{proposition}\label{testenv-proposition}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{proposition}
%
%\begin{conjecture}\label{testenv-conjecture}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{conjecture}
%
%\begin{observation}\label{testenv-observation}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{observation}
%
%\begin{exercise}\label{testenv-exercise}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{exercise}
%
%\begin{definition}\label{testenv-definition}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{definition}
%
%\begin{example}\label{testenv-example}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{example}
%
%\begin{note}\label{testenv-note}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{note}
%
%\begin{note*}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{note*}
%
%\begin{remark}\label{testenv-remark}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{remark}
%
%\begin{remark*}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{remark*}
%
%\begin{claim}\label{testenv-claim}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{claim}
%
%\begin{claim*}\label{testenv-claim2}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{claim*}
%
%\begin{proof}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{proof}
%
%\begin{claimproof}
%Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
%\end{claimproof}

\end{document}
